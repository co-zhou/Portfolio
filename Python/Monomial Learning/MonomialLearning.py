# -*- coding: utf-8 -*-
"""MonomialLearning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-FEokC1xJi9Vf_ZiA__pwMSWoBTPAhet
"""

!pip install pyeda

from pyeda.boolalg.picosat import satisfy_one
from pyeda.boolalg.bfarray import exprvars
from pyeda.inter import *
import numpy as np

def featureConstraint(X, N, P, Z):
    featureConstraints = []
    for i in range(numFeatures):
        featureConstraints += [Or(N[i], P[i], Z[i]),
                               Or(Not(N[i]), Not(P[i])),
                               Or(Not(N[i]), Not(Z[i])),
                               Or(Not(Z[i]), Not(P[i]))]

    return featureConstraints
def encodeSamples(X, Y, N, P, Z):
    sampleEncoding = []
    for i in range(X.shape[0]):
        temp = []
        if Y[i]:
            for j in range(X.shape[1]):
                if X[i][j]:
                    temp.append(Not(N[j]))
                else:
                    temp.append(Not(P[j]))
            sampleEncoding.append(And(*temp))
        else:
            for j in range(X.shape[1]):
                if X[i][j]:
                    temp.append(N[j])
                else:
                    temp.append(P[j])
            sampleEncoding.append(Or(*temp))
 
    return sampleEncoding

def literalConstraint(N, P, k):
    x = list(P) + list(N)
    n = len(x)
    S = exprvars('s', len(x), k)

#   (x0 + ¬S0,0)(¬x0 + S0,0)
    constraints = [Or(x[0], Not(S[0][0])), Or(Not(x[0]), S[0][0])]

#   Πk-1
#   j=1(¬S0,j)
    for j in range(1, k):
        constraints.append(Not(S[0][j]))

#   Πn-1
#   i=1(¬xi + ¬Si−1,k-1),
    for i in range(1, n):
        constraints.append(Or(Not(x[i]), Not(S[i-1][k-1])))

#   Πn−2
#   i=1 (xi+Si−1,0+¬Si,0)(¬xi+Si,0)(¬Si−1,0+Si,0),
    for i in range(1, n-1):
        constraints.append(Or(x[i], S[i-1][0], Not(S[i][0])))
        constraints.append(Or(Not(x[i]), S[i][0]))
        constraints.append(Or(Not(S[i-1][0]), S[i][0]))

#   Πn−2 Πk-1  (xi + Si−1,j + ¬Si,j )(Si−1,j−1 + Si−1,j +
#   i=1  j=1    ¬Si,j )(¬Si−1,j + Si,j )(¬xi + ¬Si−1,j−1 + Si,j)
    for i in range(1, n-1):
        for j in range(1, k):
            constraints.append(Or(x[i], S[i-1][j], Not(S[i][j])))
            constraints.append(Or(S[i-1][j-1], S[i-1][j], Not(S[i][j])))
            constraints.append(Or(Not(S[i-1][j]), S[i][j]))
            constraints.append(Or(Not(x[i]), Not(S[i-1][j-1]), S[i][j]))

#   (xn-1 + Sn−2,k-1)(Sn−2,k-2 + Sn−2,k-1)
    constraints.append(Or(x[n-1], S[n-2][k-1]))
    constraints.append(Or(S[n-2][k-2], S[n-2][k-1]))

    return constraints
if __name__ == "__main__":
    X = np.load("/content/drive/My Drive/ECE 157B/HW4/X_monomial.npy")
    Y = np.load("/content/drive/My Drive/ECE 157B/HW4/Y_monomial.npy")
    numFeatures = X.shape[1]
    N = exprvars("n", numFeatures)
    P = exprvars("p", numFeatures)
    Z = exprvars("z", numFeatures)

    featureConstraints = featureConstraint(X, N, P, Z)
    sampleEncodings = encodeSamples(X, Y, N, P, Z)
    literalConstraints = literalConstraint(N, P, 5)
    
    constraints = And(*(featureConstraints + sampleEncodings + literalConstraints))
    output = constraints.satisfy_one()
    answer = "f = "
    for key in output:
        if key in N and output[key]:
            answer += ("~x" + str(list(N).index(key)))
        elif key in P and output[key]:
            answer += ("x" + str(list(P).index(key)))
    print(answer)